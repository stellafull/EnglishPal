{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EnglshiPal EnglsihPal lab documentation. Team member: \u5360\u5065\u8c6a, \u738b\u5f66\u8d85, \u9648\u81f4\u8fdc, \u6c64\u4f73\u4f1f Instructor: Lanhui Index Lab1 - Dependency Analysis and Dependency Graph Lab2 - The ORM Magic Lab 3 - The Service Layer Project layout app/ main.py # Main function. ... .py # Module. static/ wordfreqapp_schema.sql # Generate database. ... ... References lanlab.org http://lanlab.org/","title":"Home"},{"location":"#englshipal","text":"EnglsihPal lab documentation. Team member: \u5360\u5065\u8c6a, \u738b\u5f66\u8d85, \u9648\u81f4\u8fdc, \u6c64\u4f73\u4f1f Instructor: Lanhui","title":"EnglshiPal"},{"location":"#index","text":"Lab1 - Dependency Analysis and Dependency Graph Lab2 - The ORM Magic Lab 3 - The Service Layer","title":"Index"},{"location":"#project-layout","text":"app/ main.py # Main function. ... .py # Module. static/ wordfreqapp_schema.sql # Generate database. ... ...","title":"Project layout"},{"location":"#references","text":"lanlab.org http://lanlab.org/","title":"References"},{"location":"lab1/","text":"LAB1 - EnglishPal Dependency Analysis and Dependency Graph Author: \u5360\u5065\u8c6a, \u738b\u5f66\u8d85, \u9648\u81f4\u8fdc, \u6c64\u4f73\u4f1f Date: 2021/5/17 Location: 22-206 Introduction EnglishPal is a website application dedicated to helping people improve their English. This lab study help us understand the current health level of the architecture of EnglishPal. Materials and Methods The module-level dependencies are captured by snakefood, and the class/function-level dependency graph for EnglilshPal is hand-drawn and can be plotted by Mermaid. Results EnglishPalModule.dot: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 strict digraph \"dependencies\" { graph [ rankdir=\"LR\", overlap=\"scale\", size=\"8,10\", ratio=\"fill\", fontsize=\"16\", fontname=\"Helvetica\", clusterrank=\"local\" ] node [ fontsize=10 shape=ellipse // style=filled // shape=box ]; \"UseSqlite.py\" [style=filled]; \"WordFreq.py\" [style=filled]; \"WordFreq.py\" -> \"wordfreqCMD.py\"; \"difficulty.py\" [style=filled]; \"difficulty.py\" -> \"wordfreqCMD.py\"; \"main.py\" [style=filled]; \"main.py\" -> \"UseSqlite.py\"; \"main.py\" -> \"WordFreq.py\"; \"main.py\" -> \"difficulty.py\"; \"main.py\" -> \"pickle_idea.py\"; \"main.py\" -> \"pickle_idea2.py\"; \"main.py\" -> \"wordfreqCMD.py\"; \"pickle_idea.py\" [style=filled]; \"pickle_idea2.py\" [style=filled]; \"wordfreqCMD.py\" [style=filled]; \"wordfreqCMD.py\" -> \"pickle_idea.py\"; } 2. class/function-level.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 graph LR load_freq_history -->pickle_idea.load_record verify_user --> Sqlite3Template.RecordQuery add_user -->Sqlite3Template.InsertQuery check_username_availability --> Sqlite3Template.RecordQuery get_expiry_date -->Sqlite3Template.RecordQuery get_today_article --> Sqlite3Template.RecordQuery get_today_article --> load_freq_history get_today_article --> difficulty.get_difficulty_level get_today_article --> user_difficulty_level get_today_article -->random.shuffle get_today_article -->random.choice get_today_article --> text_difficulty_level get_today_article --> within_range get_today_article --> get_answer_part mark_word --> load_freq_history mark_word --> pickle_idea.dict2lst mark_word --> pickle_idea.merge_frequency mark_word --> pickle_idea.save_frequency_to_pickle mainpage --> WordFreq mainpage --> load_freq_history mainpage --> pickle_idea.dict2lst mainpage --> pickle_idea.merge_frequency mainpage --> pickle_idea.save_frequency_to_pickle mainpage --> pickle_idea.dict2lst user_mark_word --> load_freq_history user_mark_word -->pickle_idea2.dict2lst user_mark_word -->pickle_idea2.merge_frequency user_mark_word -->pickle_idea2.save_frequency_to_pickle userpage --> WordFreq userpage --> pickle_idea.load_record userpage --> load_freq_history userpage --> sort_in_descending_order signup --> check_username_availability signup --> render_template signup --> add_user signup --> verify_user login --> render_template login --> verify_user difficulty.load_record --> pickle.load difficulty.difficulty_level_from_frequency --> math.log difficulty.get_difficulty_level --> revert_dict difficulty.get_difficulty_level --> sort_in_ascending_order difficulty.text_difficulty_level -->sort_in_descending_order pickle_idea.merge_frequency --> pickle_idea.lst2dict pickle_idea2.merge_frequency --> pickle_idea2.lst2dict Sqlite3Template.do --> Sqlite3Template.connect Sqlite3Template.do --> Sqlite3Template.instructions Sqlite3Template.do --> Sqlite3Template.operate WordFreq.get_freq --> wordfreqCMD.sort_in_descending_order graph LR load_freq_history -->pickle_idea.load_record verify_user --> Sqlite3Template.RecordQuery add_user -->Sqlite3Template.InsertQuery check_username_availability --> Sqlite3Template.RecordQuery get_expiry_date -->Sqlite3Template.RecordQuery get_today_article --> Sqlite3Template.RecordQuery get_today_article --> load_freq_history get_today_article --> difficulty.get_difficulty_level get_today_article --> user_difficulty_level get_today_article -->random.shuffle get_today_article -->random.choice get_today_article --> text_difficulty_level get_today_article --> within_range get_today_article --> get_answer_part mark_word --> load_freq_history mark_word --> pickle_idea.dict2lst mark_word --> pickle_idea.merge_frequency mark_word --> pickle_idea.save_frequency_to_pickle mainpage --> WordFreq mainpage --> load_freq_history mainpage --> pickle_idea.dict2lst mainpage --> pickle_idea.merge_frequency mainpage --> pickle_idea.save_frequency_to_pickle mainpage --> pickle_idea.dict2lst user_mark_word --> load_freq_history user_mark_word -->pickle_idea2.dict2lst user_mark_word -->pickle_idea2.merge_frequency user_mark_word -->pickle_idea2.save_frequency_to_pickle userpage --> WordFreq userpage --> pickle_idea.load_record userpage --> load_freq_history userpage --> sort_in_descending_order signup --> check_username_availability signup --> render_template signup --> add_user signup --> verify_user login --> render_template login --> verify_user difficulty.load_record --> pickle.load difficulty.difficulty_level_from_frequency --> math.log difficulty.get_difficulty_level --> revert_dict difficulty.get_difficulty_level --> sort_in_ascending_order difficulty.text_difficulty_level -->sort_in_descending_order pickle_idea.merge_frequency --> pickle_idea.lst2dict pickle_idea2.merge_frequency --> pickle_idea2.lst2dict Sqlite3Template.do --> Sqlite3Template.connect Sqlite3Template.do --> Sqlite3Template.instructions Sqlite3Template.do --> Sqlite3Template.operate WordFreq.get_freq --> wordfreqCMD.sort_in_descending_order 3. Pros and cons of the current architecture of EnglishPal: Shortcoming: The addition of the web pages makes the system inefficient to deliver media elements. All the processing tasks are done by the server before the delivery of the content to the client. The server inefficient to handle multiple user requests. Any development change or maintenance costs a lot. Advantages: Efficient with full-stack, no communication costs between front-end and back-end. Effective for simple and small projects, with simple CRUD and smaller codebase, it's more enough. Higher security, protecting the API from attack. Similar concept and syntax, it helps focusing on project features. It reduces the mistakes in communications. Discussions Through this lab we tried to understand the current health level of the architecture of EnglishPal. During the lab, we learnt to use Snakefood, Graphviz Online, Mermaid as well as Read the Docs. Most importantly, we mastered a basic work flow of analysing the structure and the dependency of an existing project which will sure to contribute to the future work. References Graphviz. https://graphviz.org/ Graphviz Online. https://bit.ly/3uYDiLV Read the Docs. https://readthedocs.org/ Snakefood: Python Dependency Graphs. http://furius.ca/snakefood/ Mermaid. https://mermaid-js.github.io/mermaid/#/ Jacopo Malnati. X-Ray 1.0.4.1, my Bachelor and Research Project. https://xray.inf.usi.ch/xray.php Sofia Peterson. A Brief Guide How to Write a Computer Science Lab Report. https://thehackpost.com/a-brief-guide-how-to-write-a-computer-science-lab-report.html lab1.pdf.","title":"Lab1"},{"location":"lab1/#lab1-englishpal-dependency-analysis-and-dependency-graph","text":"Author: \u5360\u5065\u8c6a, \u738b\u5f66\u8d85, \u9648\u81f4\u8fdc, \u6c64\u4f73\u4f1f Date: 2021/5/17 Location: 22-206","title":"LAB1 - EnglishPal Dependency Analysis and Dependency Graph"},{"location":"lab1/#introduction","text":"EnglishPal is a website application dedicated to helping people improve their English. This lab study help us understand the current health level of the architecture of EnglishPal.","title":"Introduction"},{"location":"lab1/#materials-and-methods","text":"The module-level dependencies are captured by snakefood, and the class/function-level dependency graph for EnglilshPal is hand-drawn and can be plotted by Mermaid.","title":"Materials and Methods"},{"location":"lab1/#results","text":"EnglishPalModule.dot: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 strict digraph \"dependencies\" { graph [ rankdir=\"LR\", overlap=\"scale\", size=\"8,10\", ratio=\"fill\", fontsize=\"16\", fontname=\"Helvetica\", clusterrank=\"local\" ] node [ fontsize=10 shape=ellipse // style=filled // shape=box ]; \"UseSqlite.py\" [style=filled]; \"WordFreq.py\" [style=filled]; \"WordFreq.py\" -> \"wordfreqCMD.py\"; \"difficulty.py\" [style=filled]; \"difficulty.py\" -> \"wordfreqCMD.py\"; \"main.py\" [style=filled]; \"main.py\" -> \"UseSqlite.py\"; \"main.py\" -> \"WordFreq.py\"; \"main.py\" -> \"difficulty.py\"; \"main.py\" -> \"pickle_idea.py\"; \"main.py\" -> \"pickle_idea2.py\"; \"main.py\" -> \"wordfreqCMD.py\"; \"pickle_idea.py\" [style=filled]; \"pickle_idea2.py\" [style=filled]; \"wordfreqCMD.py\" [style=filled]; \"wordfreqCMD.py\" -> \"pickle_idea.py\"; } 2. class/function-level.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 graph LR load_freq_history -->pickle_idea.load_record verify_user --> Sqlite3Template.RecordQuery add_user -->Sqlite3Template.InsertQuery check_username_availability --> Sqlite3Template.RecordQuery get_expiry_date -->Sqlite3Template.RecordQuery get_today_article --> Sqlite3Template.RecordQuery get_today_article --> load_freq_history get_today_article --> difficulty.get_difficulty_level get_today_article --> user_difficulty_level get_today_article -->random.shuffle get_today_article -->random.choice get_today_article --> text_difficulty_level get_today_article --> within_range get_today_article --> get_answer_part mark_word --> load_freq_history mark_word --> pickle_idea.dict2lst mark_word --> pickle_idea.merge_frequency mark_word --> pickle_idea.save_frequency_to_pickle mainpage --> WordFreq mainpage --> load_freq_history mainpage --> pickle_idea.dict2lst mainpage --> pickle_idea.merge_frequency mainpage --> pickle_idea.save_frequency_to_pickle mainpage --> pickle_idea.dict2lst user_mark_word --> load_freq_history user_mark_word -->pickle_idea2.dict2lst user_mark_word -->pickle_idea2.merge_frequency user_mark_word -->pickle_idea2.save_frequency_to_pickle userpage --> WordFreq userpage --> pickle_idea.load_record userpage --> load_freq_history userpage --> sort_in_descending_order signup --> check_username_availability signup --> render_template signup --> add_user signup --> verify_user login --> render_template login --> verify_user difficulty.load_record --> pickle.load difficulty.difficulty_level_from_frequency --> math.log difficulty.get_difficulty_level --> revert_dict difficulty.get_difficulty_level --> sort_in_ascending_order difficulty.text_difficulty_level -->sort_in_descending_order pickle_idea.merge_frequency --> pickle_idea.lst2dict pickle_idea2.merge_frequency --> pickle_idea2.lst2dict Sqlite3Template.do --> Sqlite3Template.connect Sqlite3Template.do --> Sqlite3Template.instructions Sqlite3Template.do --> Sqlite3Template.operate WordFreq.get_freq --> wordfreqCMD.sort_in_descending_order graph LR load_freq_history -->pickle_idea.load_record verify_user --> Sqlite3Template.RecordQuery add_user -->Sqlite3Template.InsertQuery check_username_availability --> Sqlite3Template.RecordQuery get_expiry_date -->Sqlite3Template.RecordQuery get_today_article --> Sqlite3Template.RecordQuery get_today_article --> load_freq_history get_today_article --> difficulty.get_difficulty_level get_today_article --> user_difficulty_level get_today_article -->random.shuffle get_today_article -->random.choice get_today_article --> text_difficulty_level get_today_article --> within_range get_today_article --> get_answer_part mark_word --> load_freq_history mark_word --> pickle_idea.dict2lst mark_word --> pickle_idea.merge_frequency mark_word --> pickle_idea.save_frequency_to_pickle mainpage --> WordFreq mainpage --> load_freq_history mainpage --> pickle_idea.dict2lst mainpage --> pickle_idea.merge_frequency mainpage --> pickle_idea.save_frequency_to_pickle mainpage --> pickle_idea.dict2lst user_mark_word --> load_freq_history user_mark_word -->pickle_idea2.dict2lst user_mark_word -->pickle_idea2.merge_frequency user_mark_word -->pickle_idea2.save_frequency_to_pickle userpage --> WordFreq userpage --> pickle_idea.load_record userpage --> load_freq_history userpage --> sort_in_descending_order signup --> check_username_availability signup --> render_template signup --> add_user signup --> verify_user login --> render_template login --> verify_user difficulty.load_record --> pickle.load difficulty.difficulty_level_from_frequency --> math.log difficulty.get_difficulty_level --> revert_dict difficulty.get_difficulty_level --> sort_in_ascending_order difficulty.text_difficulty_level -->sort_in_descending_order pickle_idea.merge_frequency --> pickle_idea.lst2dict pickle_idea2.merge_frequency --> pickle_idea2.lst2dict Sqlite3Template.do --> Sqlite3Template.connect Sqlite3Template.do --> Sqlite3Template.instructions Sqlite3Template.do --> Sqlite3Template.operate WordFreq.get_freq --> wordfreqCMD.sort_in_descending_order 3. Pros and cons of the current architecture of EnglishPal: Shortcoming: The addition of the web pages makes the system inefficient to deliver media elements. All the processing tasks are done by the server before the delivery of the content to the client. The server inefficient to handle multiple user requests. Any development change or maintenance costs a lot. Advantages: Efficient with full-stack, no communication costs between front-end and back-end. Effective for simple and small projects, with simple CRUD and smaller codebase, it's more enough. Higher security, protecting the API from attack. Similar concept and syntax, it helps focusing on project features. It reduces the mistakes in communications.","title":"Results"},{"location":"lab1/#discussions","text":"Through this lab we tried to understand the current health level of the architecture of EnglishPal. During the lab, we learnt to use Snakefood, Graphviz Online, Mermaid as well as Read the Docs. Most importantly, we mastered a basic work flow of analysing the structure and the dependency of an existing project which will sure to contribute to the future work.","title":"Discussions"},{"location":"lab1/#references","text":"Graphviz. https://graphviz.org/ Graphviz Online. https://bit.ly/3uYDiLV Read the Docs. https://readthedocs.org/ Snakefood: Python Dependency Graphs. http://furius.ca/snakefood/ Mermaid. https://mermaid-js.github.io/mermaid/#/ Jacopo Malnati. X-Ray 1.0.4.1, my Bachelor and Research Project. https://xray.inf.usi.ch/xray.php Sofia Peterson. A Brief Guide How to Write a Computer Science Lab Report. https://thehackpost.com/a-brief-guide-how-to-write-a-computer-science-lab-report.html lab1.pdf.","title":"References"},{"location":"lab2/","text":"LAB2 - The ORM Magic Author: \u5360\u5065\u8c6a, \u738b\u5f66\u8d85, \u9648\u81f4\u8fdc, \u6c64\u4f73\u4f1f Date: 2021/5/26 Location: 22-206 Introduction In this lab, we are going to learn the object-relational mapper (ORM) provided by SQLAlchemy. With ORM, we can map a class to a database table, and map an object of that class to a row in the database table. With SQLAlchemy\u2019s ORM, we can avoid directly using any raw SQL statements. More important, we will be able to follow the principle of dependency inversion \u2013 let ORM depend on the domain model, but not the other way around. We will create 3 files: model.py orm.py app.py Here app.py imports the above two python modules and generates an SQLite database exactly like EnglishPalDatabase.db. Materials and Methods Work Flow Review and analyze the requirements in lab2.pdf. Learn about the relative knowledges in Chapter 2 of the course text book. Start with the code. Search for the coding techniques required online. Finish the coding process. Summarize and Write the document. Source Codes For this part, We implemented the incomplete function, class and used property to achieve the requirements. See the source codes and comments for detail. orm.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from sqlalchemy import Table , MetaData , Column , Integer , String , Date , ForeignKey from sqlalchemy.orm import mapper , relationship import model metadata = MetaData () articles = Table ( 'articles' , metadata , Column ( 'article_id' , Integer , primary_key = True , autoincrement = True ), Column ( 'text' , String ( 10000 )), Column ( 'source' , String ( 100 )), Column ( 'date' , String ( 10 )), Column ( 'level' , Integer , nullable = False ), Column ( 'question' , String ( 1000 )), ) users = Table ( 'users' , metadata , Column ( 'username' , String ( 100 ), primary_key = True ), Column ( 'password' , String ( 64 )), Column ( 'start_date' , String ( 10 ), nullable = False ), Column ( 'expiry_date' , String ( 10 ), nullable = False ), ) newwords = Table ( 'newwords' , metadata , Column ( 'word_id' , Integer , primary_key = True , autoincrement = True ), Column ( 'username' , String ( 100 ), ForeignKey ( 'users.username' )), Column ( 'word' , String ( 20 )), Column ( 'date' , String ( 10 )), ) # ADDITION: add the reading part readings = Table ( 'readings' , metadata , Column ( 'id' , Integer , primary_key = True , autoincrement = True ), Column ( 'username' , String ( 100 ), ForeignKey ( 'users.username' )), Column ( 'article_id' , Integer , ForeignKey ( 'articles.article_id' )), ) def start_mappers (): # ADDITION: implement the start_mapper() lines_mapper = mapper ( model . User , users ) lines_mapper = mapper ( model . NewWord , newwords ) lines_mapper = mapper ( model . Article , articles ) lines_mapper = mapper ( model . Reading , readings ) # pass 2. model.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from dataclasses import dataclass from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker # ADDITION: just for convenience engine = create_engine ( r 'sqlite:///D:\\newDesktop\\\u5927\u4e09\u4e0bcourses\\SADP\\lab2\\test\\EnglishPalDatabase.db' ) get_session = sessionmaker ( bind = engine ) session = get_session () @dataclass class Article : article_id : int text : str source : str date : str level : int question : str class NewWord : def __init__ ( self , username , word = '' , date = 'yyyy-mm-dd' ): self . username = username self . word = word self . date = date class User : def __init__ ( self , username , password = '12345' , start_date = '2021-05-19' , expiry_date = '2031-05-19' ): self . username = username self . password = password self . start_date = start_date self . expiry_date = expiry_date self . _read = [] def read_article ( self , article ): # ADDITION: implement the action session . add ( article ) reading = Reading ( self . username , article . article_id ) session . add ( reading ) session . commit () # pass # ADDITION: use property to achieve list(user.newwords) @property def newwords ( self ): words = session . query ( NewWord ) . filter ( NewWord . username == self . username ) . all () # test code # for w in words: # print(w.word) return words # ADDITION: implement the Reading class class Reading : def __init__ ( self , username , article_id ): self . username = username self . article_id = article_id 3. app.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker import model import orm orm . start_mappers () engine = create_engine ( r 'sqlite:///D:\\newDesktop\\\u5927\u4e09\u4e0bcourses\\SADP\\lab2\\test\\EnglishPalDatabase.db' ) # modify the path orm . metadata . drop_all ( engine ) orm . metadata . create_all ( engine ) get_session = sessionmaker ( bind = engine ) # add two users session = get_session () try : session . add ( model . User ( username = 'mrlan' , password = '12345' , start_date = '2021-05-14' )) session . add ( model . User ( username = 'lanhui' , password = 'Hard2Guess!' , start_date = '2021-05-15' )) session . commit () except : print ( 'Duplicate insertions.' ) print ( session . query ( model . User ) . count ()) for u in session . query ( model . User ) . all (): print ( u . username ) session . close () # add a few new words session = get_session () session . add ( model . NewWord ( username = 'lanhui' , word = 'starbucks' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'lanhui' , word = 'luckin' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'lanhui' , word = 'secondcup' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'mrlan' , word = 'costa' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'mrlan' , word = 'timhortons' , date = '2021-05-15' )) session . commit () session . close () # add a few articles session = get_session () article = model . Article ( article_id = 1 , text = 'THE ORIGIN OF SPECIES BY MEANS OF NATURAL SELECTION, OR THE PRESERVATION OF FAVOURED RACES IN THE STRUGGLE FOR LIFE' , source = 'CHARLES DARWIN, M.A.' , date = '1859-01-01' , level = 5 , question = 'Are humans descended from monkeys?' ) session . add ( article ) session . commit () session . close () # query user and let him read something session = get_session () user = session . query ( model . User ) . filter_by ( username = 'lanhui' ) . one () for item in list ( user . newwords ): print ( item . word ) user . read_article ( article ) # this method call will add a row to table readings print ( '-----' ) user = session . query ( model . User ) . filter_by ( username = 'mrlan' ) . one () for item in list ( user . newwords ): print ( item . word ) user . read_article ( article ) # this method call will add a row to table readings session . commit () session . close () Results For this part we make screenshots to illustrate the results. After running app.py : Inside EnglishPalDatabase.db(Open with Navicat Premium) : list of tables: articles: newwords: readings: users: Discussions For this lab we learnt about the way to manipulate database with SQLAlchemy\u2019s ORM (object-relational mapper) instead of raw SQL statement in web application, which will bring convenience while making the architecture more clear. We tried to understand dependency inversion. Also, we learnt to use Read the Docs combining with Sphinx to manage our lab report. References lab2.pdf","title":"Lab2"},{"location":"lab2/#lab2-the-orm-magic","text":"Author: \u5360\u5065\u8c6a, \u738b\u5f66\u8d85, \u9648\u81f4\u8fdc, \u6c64\u4f73\u4f1f Date: 2021/5/26 Location: 22-206","title":"LAB2 - The ORM Magic"},{"location":"lab2/#introduction","text":"In this lab, we are going to learn the object-relational mapper (ORM) provided by SQLAlchemy. With ORM, we can map a class to a database table, and map an object of that class to a row in the database table. With SQLAlchemy\u2019s ORM, we can avoid directly using any raw SQL statements. More important, we will be able to follow the principle of dependency inversion \u2013 let ORM depend on the domain model, but not the other way around. We will create 3 files: model.py orm.py app.py Here app.py imports the above two python modules and generates an SQLite database exactly like EnglishPalDatabase.db.","title":"Introduction"},{"location":"lab2/#materials-and-methods","text":"","title":"Materials and Methods"},{"location":"lab2/#work-flow","text":"Review and analyze the requirements in lab2.pdf. Learn about the relative knowledges in Chapter 2 of the course text book. Start with the code. Search for the coding techniques required online. Finish the coding process. Summarize and Write the document.","title":"Work Flow"},{"location":"lab2/#source-codes","text":"For this part, We implemented the incomplete function, class and used property to achieve the requirements. See the source codes and comments for detail. orm.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from sqlalchemy import Table , MetaData , Column , Integer , String , Date , ForeignKey from sqlalchemy.orm import mapper , relationship import model metadata = MetaData () articles = Table ( 'articles' , metadata , Column ( 'article_id' , Integer , primary_key = True , autoincrement = True ), Column ( 'text' , String ( 10000 )), Column ( 'source' , String ( 100 )), Column ( 'date' , String ( 10 )), Column ( 'level' , Integer , nullable = False ), Column ( 'question' , String ( 1000 )), ) users = Table ( 'users' , metadata , Column ( 'username' , String ( 100 ), primary_key = True ), Column ( 'password' , String ( 64 )), Column ( 'start_date' , String ( 10 ), nullable = False ), Column ( 'expiry_date' , String ( 10 ), nullable = False ), ) newwords = Table ( 'newwords' , metadata , Column ( 'word_id' , Integer , primary_key = True , autoincrement = True ), Column ( 'username' , String ( 100 ), ForeignKey ( 'users.username' )), Column ( 'word' , String ( 20 )), Column ( 'date' , String ( 10 )), ) # ADDITION: add the reading part readings = Table ( 'readings' , metadata , Column ( 'id' , Integer , primary_key = True , autoincrement = True ), Column ( 'username' , String ( 100 ), ForeignKey ( 'users.username' )), Column ( 'article_id' , Integer , ForeignKey ( 'articles.article_id' )), ) def start_mappers (): # ADDITION: implement the start_mapper() lines_mapper = mapper ( model . User , users ) lines_mapper = mapper ( model . NewWord , newwords ) lines_mapper = mapper ( model . Article , articles ) lines_mapper = mapper ( model . Reading , readings ) # pass 2. model.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from dataclasses import dataclass from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker # ADDITION: just for convenience engine = create_engine ( r 'sqlite:///D:\\newDesktop\\\u5927\u4e09\u4e0bcourses\\SADP\\lab2\\test\\EnglishPalDatabase.db' ) get_session = sessionmaker ( bind = engine ) session = get_session () @dataclass class Article : article_id : int text : str source : str date : str level : int question : str class NewWord : def __init__ ( self , username , word = '' , date = 'yyyy-mm-dd' ): self . username = username self . word = word self . date = date class User : def __init__ ( self , username , password = '12345' , start_date = '2021-05-19' , expiry_date = '2031-05-19' ): self . username = username self . password = password self . start_date = start_date self . expiry_date = expiry_date self . _read = [] def read_article ( self , article ): # ADDITION: implement the action session . add ( article ) reading = Reading ( self . username , article . article_id ) session . add ( reading ) session . commit () # pass # ADDITION: use property to achieve list(user.newwords) @property def newwords ( self ): words = session . query ( NewWord ) . filter ( NewWord . username == self . username ) . all () # test code # for w in words: # print(w.word) return words # ADDITION: implement the Reading class class Reading : def __init__ ( self , username , article_id ): self . username = username self . article_id = article_id 3. app.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker import model import orm orm . start_mappers () engine = create_engine ( r 'sqlite:///D:\\newDesktop\\\u5927\u4e09\u4e0bcourses\\SADP\\lab2\\test\\EnglishPalDatabase.db' ) # modify the path orm . metadata . drop_all ( engine ) orm . metadata . create_all ( engine ) get_session = sessionmaker ( bind = engine ) # add two users session = get_session () try : session . add ( model . User ( username = 'mrlan' , password = '12345' , start_date = '2021-05-14' )) session . add ( model . User ( username = 'lanhui' , password = 'Hard2Guess!' , start_date = '2021-05-15' )) session . commit () except : print ( 'Duplicate insertions.' ) print ( session . query ( model . User ) . count ()) for u in session . query ( model . User ) . all (): print ( u . username ) session . close () # add a few new words session = get_session () session . add ( model . NewWord ( username = 'lanhui' , word = 'starbucks' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'lanhui' , word = 'luckin' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'lanhui' , word = 'secondcup' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'mrlan' , word = 'costa' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'mrlan' , word = 'timhortons' , date = '2021-05-15' )) session . commit () session . close () # add a few articles session = get_session () article = model . Article ( article_id = 1 , text = 'THE ORIGIN OF SPECIES BY MEANS OF NATURAL SELECTION, OR THE PRESERVATION OF FAVOURED RACES IN THE STRUGGLE FOR LIFE' , source = 'CHARLES DARWIN, M.A.' , date = '1859-01-01' , level = 5 , question = 'Are humans descended from monkeys?' ) session . add ( article ) session . commit () session . close () # query user and let him read something session = get_session () user = session . query ( model . User ) . filter_by ( username = 'lanhui' ) . one () for item in list ( user . newwords ): print ( item . word ) user . read_article ( article ) # this method call will add a row to table readings print ( '-----' ) user = session . query ( model . User ) . filter_by ( username = 'mrlan' ) . one () for item in list ( user . newwords ): print ( item . word ) user . read_article ( article ) # this method call will add a row to table readings session . commit () session . close ()","title":"Source Codes"},{"location":"lab2/#results","text":"For this part we make screenshots to illustrate the results. After running app.py : Inside EnglishPalDatabase.db(Open with Navicat Premium) : list of tables: articles: newwords: readings: users:","title":"Results"},{"location":"lab2/#discussions","text":"For this lab we learnt about the way to manipulate database with SQLAlchemy\u2019s ORM (object-relational mapper) instead of raw SQL statement in web application, which will bring convenience while making the architecture more clear. We tried to understand dependency inversion. Also, we learnt to use Read the Docs combining with Sphinx to manage our lab report.","title":"Discussions"},{"location":"lab2/#references","text":"lab2.pdf","title":"References"},{"location":"lab3/","text":"Lab 3 - The Service Layer Author: \u5360\u5065\u8c6a, \u738b\u5f66\u8d85, \u9648\u81f4\u8fdc, \u6c64\u4f73\u4f1f Date: 2021/6/7 Location: 22-206 Introduction This lab is a follow-up to Lab 2. In this lab, we are going to implement a service layer in services.py for EnglishPal, which provides a core service called read. This service would choose a suitable article for a user to read. The function read takes as input the following four arguments and returns an article ID if the user has been successfully assigned with an article to read. The function read(user, user repo, article repo, session) raises an UnknownUser exception if user does not have a correct user name or a correct password, or raises a NoArticleMatched exception if no article in the article repository, i.e., article repo, has a difficulty level matching the user\u2019s vocabulary level. We say that an article\u2019s difficulty level, La, matches a user\u2019s vocabulary level, Lu, if La > Lu. If more than one article satisfies La > Lu, then the one with the smallest La is chosen. user: a User object. The class User is defined in model.py. user repo: a UserRepository object. The class UserRepository is defined in repository.py. article repo: an ArticleRepository object. The class ArticleRepository is defined in repository.py. session: an SQLAlchemy session object. Materials and Methods Work flow Review and analyze the requirements in lab3.pdf. Learn about the relative knowledges with service layer and data layer. Start with code. Search for the coding techniques required online. Finish the coding process. Summarize and Write the document. Source Codes Modified service.py: // Modified part with code highlight 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # Software Architecture and Design Patterns -- Lab 3 starter code # An implementation of the Service Layer # Copyright (C) 2021 Hui Lan import repository import model # word and its difficulty level WORD_DIFFICULTY_LEVEL = { 'starbucks' : 5 , 'luckin' : 4 , 'secondcup' : 4 , 'costa' : 3 , 'timhortons' : 3 , 'frappuccino' : 6 } class UnknownUser ( Exception ): pass class NoArticleMatched ( Exception ): pass def read ( user , user_repo , article_repo , session ): dbuser = user_repo . get ( user . username ) if dbuser is None or dbuser . password != user . password : raise UnknownUser ( user ) wordList = session . query ( model . NewWord ) . filter ( model . NewWord . username == user . username ) . all () difficulty_list = [] for w in wordList : difficulty_list . append ( WORD_DIFFICULTY_LEVEL . get ( w . word )) difficulty_list . sort ( reverse = True ) lu = 0 count = 0 for i in difficulty_list : if count >= 3 : break lu += i count += 1 lu /= count qualified_articles = session . query ( model . Article ) . filter ( model . Article . level > lu ) . order_by ( model . Article . level ) . all () if not qualified_articles : raise NoArticleMatched else : wanted_article = qualified_articles [ 0 ] ar = article_repo . get ( wanted_article . article_id ) session . add ( ar ) dbuser . read_article ( ar ) session . commit () return wanted_article . article_id Results Discussions For this lab we learnt about the service layer, and how it work with databases. We tried to understand dependency inversion. Also, we learnt to use github page combining with mkdocs to manage our lab report and deploy it to webpages - https://stellafull.github.io/EnglishPal/lab3/ . References lab3.pdf","title":"Lab3"},{"location":"lab3/#lab-3-the-service-layer","text":"Author: \u5360\u5065\u8c6a, \u738b\u5f66\u8d85, \u9648\u81f4\u8fdc, \u6c64\u4f73\u4f1f Date: 2021/6/7 Location: 22-206","title":"Lab 3 - The Service Layer"},{"location":"lab3/#introduction","text":"This lab is a follow-up to Lab 2. In this lab, we are going to implement a service layer in services.py for EnglishPal, which provides a core service called read. This service would choose a suitable article for a user to read. The function read takes as input the following four arguments and returns an article ID if the user has been successfully assigned with an article to read. The function read(user, user repo, article repo, session) raises an UnknownUser exception if user does not have a correct user name or a correct password, or raises a NoArticleMatched exception if no article in the article repository, i.e., article repo, has a difficulty level matching the user\u2019s vocabulary level. We say that an article\u2019s difficulty level, La, matches a user\u2019s vocabulary level, Lu, if La > Lu. If more than one article satisfies La > Lu, then the one with the smallest La is chosen. user: a User object. The class User is defined in model.py. user repo: a UserRepository object. The class UserRepository is defined in repository.py. article repo: an ArticleRepository object. The class ArticleRepository is defined in repository.py. session: an SQLAlchemy session object.","title":"Introduction"},{"location":"lab3/#materials-and-methods","text":"","title":"Materials and Methods"},{"location":"lab3/#work-flow","text":"Review and analyze the requirements in lab3.pdf. Learn about the relative knowledges with service layer and data layer. Start with code. Search for the coding techniques required online. Finish the coding process. Summarize and Write the document.","title":"Work flow"},{"location":"lab3/#source-codes","text":"Modified service.py: // Modified part with code highlight 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # Software Architecture and Design Patterns -- Lab 3 starter code # An implementation of the Service Layer # Copyright (C) 2021 Hui Lan import repository import model # word and its difficulty level WORD_DIFFICULTY_LEVEL = { 'starbucks' : 5 , 'luckin' : 4 , 'secondcup' : 4 , 'costa' : 3 , 'timhortons' : 3 , 'frappuccino' : 6 } class UnknownUser ( Exception ): pass class NoArticleMatched ( Exception ): pass def read ( user , user_repo , article_repo , session ): dbuser = user_repo . get ( user . username ) if dbuser is None or dbuser . password != user . password : raise UnknownUser ( user ) wordList = session . query ( model . NewWord ) . filter ( model . NewWord . username == user . username ) . all () difficulty_list = [] for w in wordList : difficulty_list . append ( WORD_DIFFICULTY_LEVEL . get ( w . word )) difficulty_list . sort ( reverse = True ) lu = 0 count = 0 for i in difficulty_list : if count >= 3 : break lu += i count += 1 lu /= count qualified_articles = session . query ( model . Article ) . filter ( model . Article . level > lu ) . order_by ( model . Article . level ) . all () if not qualified_articles : raise NoArticleMatched else : wanted_article = qualified_articles [ 0 ] ar = article_repo . get ( wanted_article . article_id ) session . add ( ar ) dbuser . read_article ( ar ) session . commit () return wanted_article . article_id","title":"Source Codes"},{"location":"lab3/#results","text":"","title":"Results"},{"location":"lab3/#discussions","text":"For this lab we learnt about the service layer, and how it work with databases. We tried to understand dependency inversion. Also, we learnt to use github page combining with mkdocs to manage our lab report and deploy it to webpages - https://stellafull.github.io/EnglishPal/lab3/ .","title":"Discussions"},{"location":"lab3/#references","text":"lab3.pdf","title":"References"}]}