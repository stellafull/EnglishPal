{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EnglshiPal EnglsihPal lab documentation. Team member: \u5360\u5065\u8c6a, \u738b\u5f66\u8d85, \u9648\u81f4\u8fdc, \u6c64\u4f73\u4f1f Index Lab1 - Dependency Analysis and Dependency Graph Lab2 - The ORM Magic Project layout app/ main.py # Main function. ... .py # Module. static/ wordfreqapp_schema.sql # Generate database. ... ...","title":"Home"},{"location":"#englshipal","text":"EnglsihPal lab documentation. Team member: \u5360\u5065\u8c6a, \u738b\u5f66\u8d85, \u9648\u81f4\u8fdc, \u6c64\u4f73\u4f1f","title":"EnglshiPal"},{"location":"#index","text":"Lab1 - Dependency Analysis and Dependency Graph Lab2 - The ORM Magic","title":"Index"},{"location":"#project-layout","text":"app/ main.py # Main function. ... .py # Module. static/ wordfreqapp_schema.sql # Generate database. ... ...","title":"Project layout"},{"location":"lab1/","text":"EnglishPal Dependency Analysis and Dependency Graph Author: \u5360\u5065\u8c6a, \u738b\u5f66\u8d85, \u9648\u81f4\u8fdc, \u6c64\u4f73\u4f1f Date: 2021/5/17 Location: 22-206 Introduction EnglishPal is a website application dedicated to helping people improve their English. This lab study help us understand the current health level of the architecture of EnglishPal. Materials and Methods The module-level dependencies are captured by snakefood, and the class/function-level dependency graph for EnglilshPal is hand-drawn and can be plotted by Mermaid. Results EnglishPalModule.dot: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 strict digraph \"dependencies\" { graph [ rankdir=\"LR\", overlap=\"scale\", size=\"8,10\", ratio=\"fill\", fontsize=\"16\", fontname=\"Helvetica\", clusterrank=\"local\" ] node [ fontsize=10 shape=ellipse // style=filled // shape=box ]; \"UseSqlite.py\" [style=filled]; \"WordFreq.py\" [style=filled]; \"WordFreq.py\" -> \"wordfreqCMD.py\"; \"difficulty.py\" [style=filled]; \"difficulty.py\" -> \"wordfreqCMD.py\"; \"main.py\" [style=filled]; \"main.py\" -> \"UseSqlite.py\"; \"main.py\" -> \"WordFreq.py\"; \"main.py\" -> \"difficulty.py\"; \"main.py\" -> \"pickle_idea.py\"; \"main.py\" -> \"pickle_idea2.py\"; \"main.py\" -> \"wordfreqCMD.py\"; \"pickle_idea.py\" [style=filled]; \"pickle_idea2.py\" [style=filled]; \"wordfreqCMD.py\" [style=filled]; \"wordfreqCMD.py\" -> \"pickle_idea.py\"; } 2. class/function-level.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 graph LR load_freq_history -->pickle_idea.load_record verify_user --> Sqlite3Template.RecordQuery add_user -->Sqlite3Template.InsertQuery check_username_availability --> Sqlite3Template.RecordQuery get_expiry_date -->Sqlite3Template.RecordQuery get_today_article --> Sqlite3Template.RecordQuery get_today_article --> load_freq_history get_today_article --> difficulty.get_difficulty_level get_today_article --> user_difficulty_level get_today_article -->random.shuffle get_today_article -->random.choice get_today_article --> text_difficulty_level get_today_article --> within_range get_today_article --> get_answer_part mark_word --> load_freq_history mark_word --> pickle_idea.dict2lst mark_word --> pickle_idea.merge_frequency mark_word --> pickle_idea.save_frequency_to_pickle mainpage --> WordFreq mainpage --> load_freq_history mainpage --> pickle_idea.dict2lst mainpage --> pickle_idea.merge_frequency mainpage --> pickle_idea.save_frequency_to_pickle mainpage --> pickle_idea.dict2lst user_mark_word --> load_freq_history user_mark_word -->pickle_idea2.dict2lst user_mark_word -->pickle_idea2.merge_frequency user_mark_word -->pickle_idea2.save_frequency_to_pickle userpage --> WordFreq userpage --> pickle_idea.load_record userpage --> load_freq_history userpage --> sort_in_descending_order signup --> check_username_availability signup --> render_template signup --> add_user signup --> verify_user login --> render_template login --> verify_user difficulty.load_record --> pickle.load difficulty.difficulty_level_from_frequency --> math.log difficulty.get_difficulty_level --> revert_dict difficulty.get_difficulty_level --> sort_in_ascending_order difficulty.text_difficulty_level -->sort_in_descending_order pickle_idea.merge_frequency --> pickle_idea.lst2dict pickle_idea2.merge_frequency --> pickle_idea2.lst2dict Sqlite3Template.do --> Sqlite3Template.connect Sqlite3Template.do --> Sqlite3Template.instructions Sqlite3Template.do --> Sqlite3Template.operate WordFreq.get_freq --> wordfreqCMD.sort_in_descending_order graph LR load_freq_history -->pickle_idea.load_record verify_user --> Sqlite3Template.RecordQuery add_user -->Sqlite3Template.InsertQuery check_username_availability --> Sqlite3Template.RecordQuery get_expiry_date -->Sqlite3Template.RecordQuery get_today_article --> Sqlite3Template.RecordQuery get_today_article --> load_freq_history get_today_article --> difficulty.get_difficulty_level get_today_article --> user_difficulty_level get_today_article -->random.shuffle get_today_article -->random.choice get_today_article --> text_difficulty_level get_today_article --> within_range get_today_article --> get_answer_part mark_word --> load_freq_history mark_word --> pickle_idea.dict2lst mark_word --> pickle_idea.merge_frequency mark_word --> pickle_idea.save_frequency_to_pickle mainpage --> WordFreq mainpage --> load_freq_history mainpage --> pickle_idea.dict2lst mainpage --> pickle_idea.merge_frequency mainpage --> pickle_idea.save_frequency_to_pickle mainpage --> pickle_idea.dict2lst user_mark_word --> load_freq_history user_mark_word -->pickle_idea2.dict2lst user_mark_word -->pickle_idea2.merge_frequency user_mark_word -->pickle_idea2.save_frequency_to_pickle userpage --> WordFreq userpage --> pickle_idea.load_record userpage --> load_freq_history userpage --> sort_in_descending_order signup --> check_username_availability signup --> render_template signup --> add_user signup --> verify_user login --> render_template login --> verify_user difficulty.load_record --> pickle.load difficulty.difficulty_level_from_frequency --> math.log difficulty.get_difficulty_level --> revert_dict difficulty.get_difficulty_level --> sort_in_ascending_order difficulty.text_difficulty_level -->sort_in_descending_order pickle_idea.merge_frequency --> pickle_idea.lst2dict pickle_idea2.merge_frequency --> pickle_idea2.lst2dict Sqlite3Template.do --> Sqlite3Template.connect Sqlite3Template.do --> Sqlite3Template.instructions Sqlite3Template.do --> Sqlite3Template.operate WordFreq.get_freq --> wordfreqCMD.sort_in_descending_order 3. Pros and cons of the current architecture of EnglishPal: Shortcoming: The addition of the web pages makes the system inefficient to deliver media elements. All the processing tasks are done by the server before the delivery of the content to the client. The server inefficient to handle multiple user requests. Any development change or maintenance costs a lot. Advantages: Efficient with full-stack, no communication costs between front-end and back-end. Effective for simple and small projects, with simple CRUD and smaller codebase, it's more enough. Higher security, protecting the API from attack. Similar concept and syntax, it helps focusing on project features. It reduces the mistakes in communications. Discussions Through this lab we tried to understand the current health level of the architecture of EnglishPal. During the lab, we learnt to use Snakefood, Graphviz Online, Mermaid as well as Read the Docs. Most importantly, we mastered a basic work flow of analysing the structure and the dependency of an existing project which will sure to contribute to the future work. References Graphviz. https://graphviz.org/ Graphviz Online. https://bit.ly/3uYDiLV Read the Docs. https://readthedocs.org/ Snakefood: Python Dependency Graphs. http://furius.ca/snakefood/ Mermaid. https://mermaid-js.github.io/mermaid/#/ Jacopo Malnati. X-Ray 1.0.4.1, my Bachelor and Research Project. https://xray.inf.usi.ch/xray.php Sofia Peterson. A Brief Guide How to Write a Computer Science Lab Report. https://thehackpost.com/a-brief-guide-how-to-write-a-computer-science-lab-report.html lab1.pdf.","title":"Lab1"},{"location":"lab1/#englishpal-dependency-analysis-and-dependency-graph","text":"Author: \u5360\u5065\u8c6a, \u738b\u5f66\u8d85, \u9648\u81f4\u8fdc, \u6c64\u4f73\u4f1f Date: 2021/5/17 Location: 22-206","title":"EnglishPal Dependency Analysis and Dependency Graph"},{"location":"lab1/#introduction","text":"EnglishPal is a website application dedicated to helping people improve their English. This lab study help us understand the current health level of the architecture of EnglishPal.","title":"Introduction"},{"location":"lab1/#materials-and-methods","text":"The module-level dependencies are captured by snakefood, and the class/function-level dependency graph for EnglilshPal is hand-drawn and can be plotted by Mermaid.","title":"Materials and Methods"},{"location":"lab1/#results","text":"EnglishPalModule.dot: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 strict digraph \"dependencies\" { graph [ rankdir=\"LR\", overlap=\"scale\", size=\"8,10\", ratio=\"fill\", fontsize=\"16\", fontname=\"Helvetica\", clusterrank=\"local\" ] node [ fontsize=10 shape=ellipse // style=filled // shape=box ]; \"UseSqlite.py\" [style=filled]; \"WordFreq.py\" [style=filled]; \"WordFreq.py\" -> \"wordfreqCMD.py\"; \"difficulty.py\" [style=filled]; \"difficulty.py\" -> \"wordfreqCMD.py\"; \"main.py\" [style=filled]; \"main.py\" -> \"UseSqlite.py\"; \"main.py\" -> \"WordFreq.py\"; \"main.py\" -> \"difficulty.py\"; \"main.py\" -> \"pickle_idea.py\"; \"main.py\" -> \"pickle_idea2.py\"; \"main.py\" -> \"wordfreqCMD.py\"; \"pickle_idea.py\" [style=filled]; \"pickle_idea2.py\" [style=filled]; \"wordfreqCMD.py\" [style=filled]; \"wordfreqCMD.py\" -> \"pickle_idea.py\"; } 2. class/function-level.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 graph LR load_freq_history -->pickle_idea.load_record verify_user --> Sqlite3Template.RecordQuery add_user -->Sqlite3Template.InsertQuery check_username_availability --> Sqlite3Template.RecordQuery get_expiry_date -->Sqlite3Template.RecordQuery get_today_article --> Sqlite3Template.RecordQuery get_today_article --> load_freq_history get_today_article --> difficulty.get_difficulty_level get_today_article --> user_difficulty_level get_today_article -->random.shuffle get_today_article -->random.choice get_today_article --> text_difficulty_level get_today_article --> within_range get_today_article --> get_answer_part mark_word --> load_freq_history mark_word --> pickle_idea.dict2lst mark_word --> pickle_idea.merge_frequency mark_word --> pickle_idea.save_frequency_to_pickle mainpage --> WordFreq mainpage --> load_freq_history mainpage --> pickle_idea.dict2lst mainpage --> pickle_idea.merge_frequency mainpage --> pickle_idea.save_frequency_to_pickle mainpage --> pickle_idea.dict2lst user_mark_word --> load_freq_history user_mark_word -->pickle_idea2.dict2lst user_mark_word -->pickle_idea2.merge_frequency user_mark_word -->pickle_idea2.save_frequency_to_pickle userpage --> WordFreq userpage --> pickle_idea.load_record userpage --> load_freq_history userpage --> sort_in_descending_order signup --> check_username_availability signup --> render_template signup --> add_user signup --> verify_user login --> render_template login --> verify_user difficulty.load_record --> pickle.load difficulty.difficulty_level_from_frequency --> math.log difficulty.get_difficulty_level --> revert_dict difficulty.get_difficulty_level --> sort_in_ascending_order difficulty.text_difficulty_level -->sort_in_descending_order pickle_idea.merge_frequency --> pickle_idea.lst2dict pickle_idea2.merge_frequency --> pickle_idea2.lst2dict Sqlite3Template.do --> Sqlite3Template.connect Sqlite3Template.do --> Sqlite3Template.instructions Sqlite3Template.do --> Sqlite3Template.operate WordFreq.get_freq --> wordfreqCMD.sort_in_descending_order graph LR load_freq_history -->pickle_idea.load_record verify_user --> Sqlite3Template.RecordQuery add_user -->Sqlite3Template.InsertQuery check_username_availability --> Sqlite3Template.RecordQuery get_expiry_date -->Sqlite3Template.RecordQuery get_today_article --> Sqlite3Template.RecordQuery get_today_article --> load_freq_history get_today_article --> difficulty.get_difficulty_level get_today_article --> user_difficulty_level get_today_article -->random.shuffle get_today_article -->random.choice get_today_article --> text_difficulty_level get_today_article --> within_range get_today_article --> get_answer_part mark_word --> load_freq_history mark_word --> pickle_idea.dict2lst mark_word --> pickle_idea.merge_frequency mark_word --> pickle_idea.save_frequency_to_pickle mainpage --> WordFreq mainpage --> load_freq_history mainpage --> pickle_idea.dict2lst mainpage --> pickle_idea.merge_frequency mainpage --> pickle_idea.save_frequency_to_pickle mainpage --> pickle_idea.dict2lst user_mark_word --> load_freq_history user_mark_word -->pickle_idea2.dict2lst user_mark_word -->pickle_idea2.merge_frequency user_mark_word -->pickle_idea2.save_frequency_to_pickle userpage --> WordFreq userpage --> pickle_idea.load_record userpage --> load_freq_history userpage --> sort_in_descending_order signup --> check_username_availability signup --> render_template signup --> add_user signup --> verify_user login --> render_template login --> verify_user difficulty.load_record --> pickle.load difficulty.difficulty_level_from_frequency --> math.log difficulty.get_difficulty_level --> revert_dict difficulty.get_difficulty_level --> sort_in_ascending_order difficulty.text_difficulty_level -->sort_in_descending_order pickle_idea.merge_frequency --> pickle_idea.lst2dict pickle_idea2.merge_frequency --> pickle_idea2.lst2dict Sqlite3Template.do --> Sqlite3Template.connect Sqlite3Template.do --> Sqlite3Template.instructions Sqlite3Template.do --> Sqlite3Template.operate WordFreq.get_freq --> wordfreqCMD.sort_in_descending_order 3. Pros and cons of the current architecture of EnglishPal: Shortcoming: The addition of the web pages makes the system inefficient to deliver media elements. All the processing tasks are done by the server before the delivery of the content to the client. The server inefficient to handle multiple user requests. Any development change or maintenance costs a lot. Advantages: Efficient with full-stack, no communication costs between front-end and back-end. Effective for simple and small projects, with simple CRUD and smaller codebase, it's more enough. Higher security, protecting the API from attack. Similar concept and syntax, it helps focusing on project features. It reduces the mistakes in communications.","title":"Results"},{"location":"lab1/#discussions","text":"Through this lab we tried to understand the current health level of the architecture of EnglishPal. During the lab, we learnt to use Snakefood, Graphviz Online, Mermaid as well as Read the Docs. Most importantly, we mastered a basic work flow of analysing the structure and the dependency of an existing project which will sure to contribute to the future work.","title":"Discussions"},{"location":"lab1/#references","text":"Graphviz. https://graphviz.org/ Graphviz Online. https://bit.ly/3uYDiLV Read the Docs. https://readthedocs.org/ Snakefood: Python Dependency Graphs. http://furius.ca/snakefood/ Mermaid. https://mermaid-js.github.io/mermaid/#/ Jacopo Malnati. X-Ray 1.0.4.1, my Bachelor and Research Project. https://xray.inf.usi.ch/xray.php Sofia Peterson. A Brief Guide How to Write a Computer Science Lab Report. https://thehackpost.com/a-brief-guide-how-to-write-a-computer-science-lab-report.html lab1.pdf.","title":"References"},{"location":"lab2/","text":"The ORM Magic Author: \u5360\u5065\u8c6a, \u738b\u5f66\u8d85, \u9648\u81f4\u8fdc, \u6c64\u4f73\u4f1f Date: 2021/5/25 Location: 22-206 Introduction In this lab, we are going to learn the object-relational mapper (ORM) provided by SQLAlchemy. With ORM, we can map a class to a database table, and map an object of that class to a row in the database table. With SQLAlchemy\u2019s ORM, we can avoid directly using any raw SQL statements. More important,we will be able to follow the principle of dependency inversion \u2013 let ORM depend on the domain model,but not the other way around. We will create 3 files: model.py orm.py app.py Here app.py imports the above two python modules and generates an SQLite database exactly like EnglishPalDatabase.db Materials and Methods Work Flow Review and analyze the requirements in lab2.pdf. Learn about the relative knowledges in Chapter 2 of the course text book. Start with the code. Search for the coding techniques required online. Finish the coding process. Summarize and Write the document. Source Codes For this part, We implemented the incomplete function, class and used property to achieve the requirements. See the source codes and comments for detail. orm.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # Software Architecture and Design Patterns -- Lab 2 starter code # Copyright (C) 2021 Hui Lan from sqlalchemy import Table , MetaData , Column , Integer , String , Date , ForeignKey from sqlalchemy.orm import mapper , relationship import model metadata = MetaData () articles = Table ( 'articles' , metadata , Column ( 'article_id' , Integer , primary_key = True , autoincrement = True ), Column ( 'text' , String ( 10000 )), Column ( 'source' , String ( 100 )), Column ( 'date' , String ( 10 )), Column ( 'level' , Integer , nullable = False ), Column ( 'question' , String ( 1000 )), ) users = Table ( 'users' , metadata , Column ( 'username' , String ( 100 ), primary_key = True ), Column ( 'password' , String ( 64 )), Column ( 'start_date' , String ( 10 ), nullable = False ), Column ( 'expiry_date' , String ( 10 ), nullable = False ), ) newwords = Table ( 'newwords' , metadata , Column ( 'word_id' , Integer , primary_key = True , autoincrement = True ), Column ( 'username' , String ( 100 ), ForeignKey ( 'users.username' )), Column ( 'word' , String ( 20 )), Column ( 'date' , String ( 10 )), ) # ADDITION: add the reading part readings = Table ( 'readings' , metadata , Column ( 'id' , Integer , primary_key = True , autoincrement = True ), Column ( 'username' , String ( 100 ), ForeignKey ( 'users.username' )), Column ( 'article_id' , Integer , ForeignKey ( 'articles.article_id' )), ) def start_mappers (): # ADDITION: implement the start_mapper() lines_mapper = mapper ( model . User , users ) lines_mapper = mapper ( model . NewWord , newwords ) lines_mapper = mapper ( model . Article , articles ) lines_mapper = mapper ( model . Reading , readings ) # pass 2. model.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 # Software Architecture and Design Patterns -- Lab 2 starter code # Copyright (C) 2021 Hui Lan from dataclasses import dataclass from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker # ADDITION: just for convenience engine = create_engine ( r 'sqlite:///D:\\newDesktop\\\u5927\u4e09\u4e0bcourses\\SADP\\lab2\\test\\EnglishPalDatabase.db' ) get_session = sessionmaker ( bind = engine ) session = get_session () @dataclass class Article : article_id : int text : str source : str date : str level : int question : str class NewWord : def __init__ ( self , username , word = '' , date = 'yyyy-mm-dd' ): self . username = username self . word = word self . date = date class User : def __init__ ( self , username , password = '12345' , start_date = '2021-05-19' , expiry_date = '2031-05-19' ): self . username = username self . password = password self . start_date = start_date self . expiry_date = expiry_date self . _read = [] def read_article ( self , article ): # ADDITION: implement the action session . add ( article ) reading = Reading ( self . username , article . article_id ) session . add ( reading ) session . commit () # pass # ADDITION: use property to achieve list(user.newwords) @property def newwords ( self ): words = session . query ( NewWord ) . filter ( NewWord . username == self . username ) . all () # test code # for w in words: # print(w.word) return words # ADDITION: implement the Reading class class Reading : def __init__ ( self , username , article_id ): self . username = username self . article_id = article_id 3. app.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 # Software Architecture and Design Patterns -- Lab 2 starter code # Copyright (C) 2021 Hui Lan from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker import model import orm orm . start_mappers () engine = create_engine ( r 'sqlite:///D:\\newDesktop\\\u5927\u4e09\u4e0bcourses\\SADP\\lab2\\test\\EnglishPalDatabase.db' ) # modify the path orm . metadata . drop_all ( engine ) orm . metadata . create_all ( engine ) get_session = sessionmaker ( bind = engine ) # add two users session = get_session () try : session . add ( model . User ( username = 'mrlan' , password = '12345' , start_date = '2021-05-14' )) session . add ( model . User ( username = 'lanhui' , password = 'Hard2Guess!' , start_date = '2021-05-15' )) session . commit () except : print ( 'Duplicate insertions.' ) print ( session . query ( model . User ) . count ()) for u in session . query ( model . User ) . all (): print ( u . username ) session . close () # add a few new words session = get_session () session . add ( model . NewWord ( username = 'lanhui' , word = 'starbucks' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'lanhui' , word = 'luckin' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'lanhui' , word = 'secondcup' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'mrlan' , word = 'costa' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'mrlan' , word = 'timhortons' , date = '2021-05-15' )) session . commit () session . close () # add a few articles session = get_session () article = model . Article ( article_id = 1 , text = 'THE ORIGIN OF SPECIES BY MEANS OF NATURAL SELECTION, OR THE PRESERVATION OF FAVOURED RACES IN THE STRUGGLE FOR LIFE' , source = 'CHARLES DARWIN, M.A.' , date = '1859-01-01' , level = 5 , question = 'Are humans descended from monkeys?' ) session . add ( article ) session . commit () session . close () # query user and let him read something session = get_session () user = session . query ( model . User ) . filter_by ( username = 'lanhui' ) . one () for item in list ( user . newwords ): print ( item . word ) user . read_article ( article ) # this method call will add a row to table readings print ( '-----' ) user = session . query ( model . User ) . filter_by ( username = 'mrlan' ) . one () for item in list ( user . newwords ): print ( item . word ) user . read_article ( article ) # this method call will add a row to table readings session . commit () session . close () Results For this part we make screenshots to illustrate the results. After running app.py : Inside EnglishPalDatabase.db(Open with Navicat Premium) : list of tables: articles: newwords: readings: users: Discussions For this lab we learnt about the way to manipulate database with SQLAlchemy\u2019s ORM (object-relational mapper) instead of raw SQL statement in web application, which will bring convenience while making the architecture more clear. We tried to understand dependency inversion. Also, we learnt to use Read the Docs combining with Sphinx to manage our lab report. References lab2.pdf","title":"Lab2"},{"location":"lab2/#the-orm-magic","text":"Author: \u5360\u5065\u8c6a, \u738b\u5f66\u8d85, \u9648\u81f4\u8fdc, \u6c64\u4f73\u4f1f Date: 2021/5/25 Location: 22-206","title":"The ORM Magic"},{"location":"lab2/#introduction","text":"In this lab, we are going to learn the object-relational mapper (ORM) provided by SQLAlchemy. With ORM, we can map a class to a database table, and map an object of that class to a row in the database table. With SQLAlchemy\u2019s ORM, we can avoid directly using any raw SQL statements. More important,we will be able to follow the principle of dependency inversion \u2013 let ORM depend on the domain model,but not the other way around. We will create 3 files: model.py orm.py app.py Here app.py imports the above two python modules and generates an SQLite database exactly like EnglishPalDatabase.db","title":"Introduction"},{"location":"lab2/#materials-and-methods","text":"","title":"Materials and Methods"},{"location":"lab2/#work-flow","text":"Review and analyze the requirements in lab2.pdf. Learn about the relative knowledges in Chapter 2 of the course text book. Start with the code. Search for the coding techniques required online. Finish the coding process. Summarize and Write the document.","title":"Work Flow"},{"location":"lab2/#source-codes","text":"For this part, We implemented the incomplete function, class and used property to achieve the requirements. See the source codes and comments for detail. orm.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # Software Architecture and Design Patterns -- Lab 2 starter code # Copyright (C) 2021 Hui Lan from sqlalchemy import Table , MetaData , Column , Integer , String , Date , ForeignKey from sqlalchemy.orm import mapper , relationship import model metadata = MetaData () articles = Table ( 'articles' , metadata , Column ( 'article_id' , Integer , primary_key = True , autoincrement = True ), Column ( 'text' , String ( 10000 )), Column ( 'source' , String ( 100 )), Column ( 'date' , String ( 10 )), Column ( 'level' , Integer , nullable = False ), Column ( 'question' , String ( 1000 )), ) users = Table ( 'users' , metadata , Column ( 'username' , String ( 100 ), primary_key = True ), Column ( 'password' , String ( 64 )), Column ( 'start_date' , String ( 10 ), nullable = False ), Column ( 'expiry_date' , String ( 10 ), nullable = False ), ) newwords = Table ( 'newwords' , metadata , Column ( 'word_id' , Integer , primary_key = True , autoincrement = True ), Column ( 'username' , String ( 100 ), ForeignKey ( 'users.username' )), Column ( 'word' , String ( 20 )), Column ( 'date' , String ( 10 )), ) # ADDITION: add the reading part readings = Table ( 'readings' , metadata , Column ( 'id' , Integer , primary_key = True , autoincrement = True ), Column ( 'username' , String ( 100 ), ForeignKey ( 'users.username' )), Column ( 'article_id' , Integer , ForeignKey ( 'articles.article_id' )), ) def start_mappers (): # ADDITION: implement the start_mapper() lines_mapper = mapper ( model . User , users ) lines_mapper = mapper ( model . NewWord , newwords ) lines_mapper = mapper ( model . Article , articles ) lines_mapper = mapper ( model . Reading , readings ) # pass 2. model.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 # Software Architecture and Design Patterns -- Lab 2 starter code # Copyright (C) 2021 Hui Lan from dataclasses import dataclass from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker # ADDITION: just for convenience engine = create_engine ( r 'sqlite:///D:\\newDesktop\\\u5927\u4e09\u4e0bcourses\\SADP\\lab2\\test\\EnglishPalDatabase.db' ) get_session = sessionmaker ( bind = engine ) session = get_session () @dataclass class Article : article_id : int text : str source : str date : str level : int question : str class NewWord : def __init__ ( self , username , word = '' , date = 'yyyy-mm-dd' ): self . username = username self . word = word self . date = date class User : def __init__ ( self , username , password = '12345' , start_date = '2021-05-19' , expiry_date = '2031-05-19' ): self . username = username self . password = password self . start_date = start_date self . expiry_date = expiry_date self . _read = [] def read_article ( self , article ): # ADDITION: implement the action session . add ( article ) reading = Reading ( self . username , article . article_id ) session . add ( reading ) session . commit () # pass # ADDITION: use property to achieve list(user.newwords) @property def newwords ( self ): words = session . query ( NewWord ) . filter ( NewWord . username == self . username ) . all () # test code # for w in words: # print(w.word) return words # ADDITION: implement the Reading class class Reading : def __init__ ( self , username , article_id ): self . username = username self . article_id = article_id 3. app.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 # Software Architecture and Design Patterns -- Lab 2 starter code # Copyright (C) 2021 Hui Lan from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker import model import orm orm . start_mappers () engine = create_engine ( r 'sqlite:///D:\\newDesktop\\\u5927\u4e09\u4e0bcourses\\SADP\\lab2\\test\\EnglishPalDatabase.db' ) # modify the path orm . metadata . drop_all ( engine ) orm . metadata . create_all ( engine ) get_session = sessionmaker ( bind = engine ) # add two users session = get_session () try : session . add ( model . User ( username = 'mrlan' , password = '12345' , start_date = '2021-05-14' )) session . add ( model . User ( username = 'lanhui' , password = 'Hard2Guess!' , start_date = '2021-05-15' )) session . commit () except : print ( 'Duplicate insertions.' ) print ( session . query ( model . User ) . count ()) for u in session . query ( model . User ) . all (): print ( u . username ) session . close () # add a few new words session = get_session () session . add ( model . NewWord ( username = 'lanhui' , word = 'starbucks' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'lanhui' , word = 'luckin' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'lanhui' , word = 'secondcup' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'mrlan' , word = 'costa' , date = '2021-05-15' )) session . add ( model . NewWord ( username = 'mrlan' , word = 'timhortons' , date = '2021-05-15' )) session . commit () session . close () # add a few articles session = get_session () article = model . Article ( article_id = 1 , text = 'THE ORIGIN OF SPECIES BY MEANS OF NATURAL SELECTION, OR THE PRESERVATION OF FAVOURED RACES IN THE STRUGGLE FOR LIFE' , source = 'CHARLES DARWIN, M.A.' , date = '1859-01-01' , level = 5 , question = 'Are humans descended from monkeys?' ) session . add ( article ) session . commit () session . close () # query user and let him read something session = get_session () user = session . query ( model . User ) . filter_by ( username = 'lanhui' ) . one () for item in list ( user . newwords ): print ( item . word ) user . read_article ( article ) # this method call will add a row to table readings print ( '-----' ) user = session . query ( model . User ) . filter_by ( username = 'mrlan' ) . one () for item in list ( user . newwords ): print ( item . word ) user . read_article ( article ) # this method call will add a row to table readings session . commit () session . close ()","title":"Source Codes"},{"location":"lab2/#results","text":"For this part we make screenshots to illustrate the results. After running app.py : Inside EnglishPalDatabase.db(Open with Navicat Premium) : list of tables: articles: newwords: readings: users:","title":"Results"},{"location":"lab2/#discussions","text":"For this lab we learnt about the way to manipulate database with SQLAlchemy\u2019s ORM (object-relational mapper) instead of raw SQL statement in web application, which will bring convenience while making the architecture more clear. We tried to understand dependency inversion. Also, we learnt to use Read the Docs combining with Sphinx to manage our lab report.","title":"Discussions"},{"location":"lab2/#references","text":"lab2.pdf","title":"References"}]}